// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2015.2
// Copyright (C) 2015 Xilinx Inc. All rights reserved.
// 
// ==============================================================


`timescale 1 ns / 1 ps

module AESL_axi_s_image_V (
	clk,
	reset,
	TRAN_image_V_TDATA,
	TRAN_image_V_TVALID,
	TRAN_image_V_TREADY,
	ready,
	done);

//------------------------Parameter----------------------
`define TV_IN_image_V_TDATA "../tv/cdatafile/c.convolve.autotvin_image_V.dat"
`define INGRESS_STATUS_image_V_TDATA "../tv/stream_size/stream_ingress_status_image_V.dat"
// Input and Output
input clk;
input reset;
output [7:0] TRAN_image_V_TDATA;
output  TRAN_image_V_TVALID;
input  TRAN_image_V_TREADY;
input ready;
input done;

//------------------------Local signal-------------------
reg [7 : 0] mem_image_V_TDATA [784 : 0];
initial begin : initialize_mem_image_V_TDATA
	integer i;
	for (i = 0; i < 784; i = i + 1) begin
		mem_image_V_TDATA[i] = 0;
	end
end
wire image_V_TDATA_empty;
wire image_V_TDATA_full;
reg [11 : 0] image_V_TDATA_mInPtr = 0;
reg [11 : 0] image_V_TDATA_mOutPtr = 0;
reg image_V_TDATA_mFlag_nEF_hint = 0; // 0: empty hint, 1: full hint

assign TRAN_image_V_TDATA = mem_image_V_TDATA[image_V_TDATA_mOutPtr];
assign image_V_TDATA_empty = ((image_V_TDATA_mInPtr == image_V_TDATA_mOutPtr) && image_V_TDATA_mFlag_nEF_hint == 1'b0) ? 1'b1: 1'b0;
assign image_V_TDATA_full = ((image_V_TDATA_mInPtr == image_V_TDATA_mOutPtr) && image_V_TDATA_mFlag_nEF_hint == 1'b1) ? 1'b1: 1'b0;

reg image_V_TDATA_valid = 0; // ingress buffer indicator: image_V_TDATA
assign TRAN_image_V_TVALID = ~(image_V_TDATA_empty) || (image_V_TDATA_valid);

//------------------------Task and function--------------
function is_blank_char(input [7:0] char);
	if (char == " " || char == "\011" || char == "\012" || char == "\015") begin
		is_blank_char = 1;
	end else begin
		is_blank_char = 0;
	end
endfunction

function [183:0] read_token(input integer fp);
	reg [7:0] char;
	begin
		read_token = "";
		char = " ";
		while (is_blank_char(char) && char != 8'hff) begin
			char = $fgetc(fp);
		end
		while (~is_blank_char(char) && char != 8'hff) begin
			read_token = {read_token[183 - 8:0], char[7:0]};
			char = $fgetc(fp);
		end
	end
endfunction

task rm_0x(inout [183:0] token);
	reg [183:0] token_tmp;
	integer i;
	begin
		token_tmp = "";
		for (i = 0; token[15:0] != "0x"; token = token >> 8) begin
			token_tmp = (token[7:0] << (8 * i)) | token_tmp;
			i = i + 1;
		end
		token = token_tmp;
	end
endtask

//------------------------Read-only axi_s-------------------
// Write operation for read_only axi_s port
initial begin : image_V_TDATA_read_file_process
  integer fp;
  integer fp_ingress_status;
  integer err;
  integer ret;
  integer transaction_idx;
  reg [183 : 0] token;
  reg [183 : 0] token_ingress_status;
  reg [31 : 0] ingress_status_image_V_TDATA;
  reg [8 : 0] mem_image_V_TDATA_tmp ;
  reg [8*5 : 1] str;
  image_V_TDATA_mInPtr = 0;
  image_V_TDATA_mFlag_nEF_hint = 0;
  transaction_idx = 0;
  image_V_TDATA_valid = 0;
  fp = $fopen(`TV_IN_image_V_TDATA, "r");
  if (fp == 0) begin // Failed to open file
	    $display("Failed to open file \"%s\"!", `TV_IN_image_V_TDATA);
	    $finish;
  end
  token = read_token(fp);
  fp_ingress_status = $fopen(`INGRESS_STATUS_image_V_TDATA, "r");
  if (fp_ingress_status == 0) begin // Failed to open file
	    $display("Failed to open file \"%s\"!", `INGRESS_STATUS_image_V_TDATA);
	    $finish;
  end
  token_ingress_status = read_token(fp_ingress_status);
  if (token != "[[[runtime]]]"
  || token_ingress_status != "[[[runtime]]]"
  ) begin // Illegal format
      $display("ERROR: Simulation using HLS TB failed.");
	    $finish;
  end
  token = read_token(fp);
  token_ingress_status = read_token(fp_ingress_status);
  while (token != "[[[/runtime]]]"
  && token_ingress_status != "[[[/runtime]]]"
  ) begin
      if (token != "[[transaction]]"
      || token_ingress_status != "[[transaction]]"
      ) begin
          $display("ERROR: Simulation using HLS TB failed.");
          $finish;
      end
      token = read_token(fp); // skip transaction number
      token_ingress_status = read_token(fp_ingress_status); // skip transaction number
      token_ingress_status = read_token(fp_ingress_status); // load ingress status at beginning of transaction
      @(posedge clk);
      # 0.2;
      while (ready !== 1) begin
          @(posedge clk);
          # 0.2;
      end
      token = read_token(fp);
      ret = $sscanf(token_ingress_status, "%d", ingress_status_image_V_TDATA);
      token_ingress_status = read_token(fp_ingress_status);
      image_V_TDATA_mInPtr = 0;
      while (token != "[[/transaction]]"
      && token_ingress_status != "[[/transaction]]"
      ) begin
          if (image_V_TDATA_mInPtr >= 784) begin
              $display("Fifo overflow!");
  	        $finish;
          end
          ret = $sscanf(token, "0x%x", mem_image_V_TDATA_tmp);
          mem_image_V_TDATA[image_V_TDATA_mInPtr] = mem_image_V_TDATA_tmp;
          if (ret != 1) begin
              $display("Failed to parse token!");
              $finish;
          end
          image_V_TDATA_mInPtr = image_V_TDATA_mInPtr + 1;
          token = read_token(fp);
          ret = $sscanf(token_ingress_status, "%d", ingress_status_image_V_TDATA);
          token_ingress_status = read_token(fp_ingress_status);
      end
      image_V_TDATA_mFlag_nEF_hint = 0;
      token = read_token(fp); // skip [[transaction]]
      image_V_TDATA_valid = (ingress_status_image_V_TDATA > 0);
      token_ingress_status = read_token(fp_ingress_status); // skip [[transaction]]
      transaction_idx = transaction_idx + 1;
  end
  $fclose(fp);
  @(posedge clk);
  # 0.2;
  while (ready !== 1) begin
  # 0.2;
      @(posedge clk);
  end
  image_V_TDATA_mFlag_nEF_hint = 1;
end

// Read operation for read_only axi_s signal image_V_TDATA
always @ (posedge clk) begin
    if (reset === 0) begin
      image_V_TDATA_mOutPtr = 0;
  end
  else if (TRAN_image_V_TVALID && TRAN_image_V_TREADY) begin
	    if (image_V_TDATA_mOutPtr < image_V_TDATA_mInPtr)
	        image_V_TDATA_mOutPtr <= image_V_TDATA_mOutPtr + 1;
  end
end

// Reset mOutPtr when done is pulled up
initial begin : done_reset_image_V_TDATA_mOutPtr_process
  while (1) begin
      @(posedge clk);
      # 0.1;
      while (ready !== 1) begin
          @(posedge clk);
          # 0.1;
      end
      image_V_TDATA_mOutPtr = 0;
  end
end

endmodule
